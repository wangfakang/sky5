{
  "name": "Sky5",
  "tagline": "proxy_pass  set var 　proxy_pass 后面跟变量和常量对性能的影响",
  "body": "`` proxy_pass后面使用变量时性能的影响的分析：\r\n``\r\n\r\n\r\nproxy_pass后面使用变量时性能的影响:\r\n\r\n\r\n１．在proxy_pass模块中后面跟变量与常量的区别：      \r\n====   \r\n    (1).如果在proxy_pass后面给的是一个具体的upstream，则nginx在proxy_pass模块的\r\n    时候会设置proxy_length为null则后面就不会执行ngx_http_proxy_eval就导致resolved\r\n    为null，则在upstream模块的时候ngx_http_upstream_init_request中就直接执行\r\n    uscf = u->conf->upstream不会去遍历upstream list.\r\n    (2).否则在proxy_pass中ngx_http_script_variables_count中统计变量的个数是不为０的，\r\n    则会执行ngx_http_script_compile函数会执行ngx_http_script_init_arrys函数(这个函\r\n    数会进行相关变量长度的分配工作)，最后在ngx_http_proxy_handler中判断其proxy_length\r\n    进行执行ngx_http_proxy_eval函数，在这个函数中会调用ngx_parse_url函数进行相关url的\r\n    解析工作而且还会为resolved进行分配空间，最后在upstream模块中调用\r\n    ngx_http_upstream_init_request中就会去访问相应的upstream　list从而来进行判断\r\n    （umcf->upstreams.elts）当proxy_pass后面给的是变量的时候根据上面知道，没来一个\r\n    请求的时候就会去遍历upstream list，这样会是qps的一个性能瓶颈，在tengine中为了解\r\n    决这个问题，使用了red_black_tree来解决这个问题－－－使用红黑树来存储upstream.\r\n    （3）.还有一个区别就是如果proxy_pass后面这个是变量，而且是一个域名的话则在后面访问\r\n    的时候都会去重新解析该域名的ip（有效期是TTL），注意如果某个时候域名解析服务器出错了\r\n    则会导致用户访问直接502.\r\n    \r\n\r\n\r\n\r\n２．proxy_pass后面的url最后有反斜杠的区别：    \r\n====   \r\n    当proxy_pass后面给的url有加反斜杠的时候，此时不会把当前location中的path加到proxy_pass后面，\r\n    否则会加上的．\r\n\r\n\r\n３．什么时候proxy_pass后面必须要给一个变量： \r\n====  \r\n\r\n    什么时候需要使用变量，那就看看使用变量与否的区别是啥就一目了然了．\r\n\r\n\r\n\r\n４．相关防盗链（摘自知道）:\r\n====  \r\n\r\n    (1).nginx为了实现反向代理的需求而增加了一个ngx_http_proxy_module模块。\r\n    其中proxy_set_header指令就是该模块需要读取的配置文件。在这里，所有设置\r\n    的值的含义和http请求同中的含义完全相同，除了Host外还有X-Forward-For。\r\n    Host的含义是表明请求的主机名，因为nginx作为反向代理使用，而如果后端真\r\n    是的服务器设置有类似防盗链或者根据http请求头中的host字段来进行路由或\r\n    判断功能的话，如果反向代理层的nginx不重写请求头中的host字段，将会导致\r\n    请求失败【默认反向代理服务器会向后端真实服务器发送请求，并且请求头中的\r\n    host字段应为proxy_pass指令设置的服务器】。\r\n    (2).同理，X_Forward_For字段表示该条http请求是有谁发起的？如果反向代理服务\r\n    器不重写该请求头的话，那么后端真实服务器在处理时会认为所有的请求都来在反向\r\n    代理服务器，如果后端有防攻击策略的话，那么机器就被封掉了。因此，在配置用作\r\n    反向代理的nginx中一般会增加两条配置，修改http的请求头：\r\n    proxy_set_header Host $http_host;\r\n    proxy_set_header X-Forward-For $remote_addr;\r\n\r\n    (3).这里的$http_host和$remote_addr都是nginx的导出变量，可以再配置文件中直接\r\n    使用。如果Host请求头部没有出现在请求头中，则$http_host值为空，但是$host值为\r\n    主域名。因此，一般而言，会用$host代替$http_host变量，从而避免http请求中丢失\r\n    Host头部的情况下Host不被重写的失误．\r\n\r\n\r\n\r\n## 有问题反馈\r\n在使用中有任何问题，欢迎反馈给我，可以用以下联系方式跟我交流\r\n\r\n* 邮件(1031379296#qq.com, 把#换成@)\r\n* QQ: 1031379296\r\n* weibo: [@王发康](http://weibo.com/u/2786211992/home)\r\n\r\n\r\n## 感激\r\n\r\n### chunshengsterATgmail.com\r\n\r\n\r\n## 关于作者\r\n\r\n### Linux\\nginx\\golang\\c\\c++爱好者\r\n### 欢迎一起交流  一起学习# \r\n",
  "google": "proxy_pass  set var 　proxy_pass 后面跟变量和常量对性能的影响",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}